//HashTable Student List program with help from Pranav with generator portion of project
#pragma warning(disable : 4996)
#include <vector>
#include <sstream>
#include <cstring>
#include "student.h"
#include "Generator.h"
#include <string>
#include <fstream>
#include <iomanip>

using namespace std;


Generator* generator = new Generator();
int hashSize = 100;
vector<int> ids;// stores the ids to make sure there are no repeats
Student** hashTable = new Student* [hashSize];
//function prototypes
void addStudent(Student* student);
void printStudent();
void deleteStudent(int id);
bool getInfo(Student* &newstudent);
void rehash();


int main() {
	//set variables
	string input;
	int key;
	int value;
	bool validinput = false;
	bool running = true;
	bool keepadding = true;
	string answer;
	string type;
	int amount;

	// initilizes array to make sure they are all NULL
	for (int i = 0; i < hashSize; i++) {
		hashTable[i] = NULL;
	}

//while the program is still running do the following
	while (running == true) {
		//tell user the commands
		cout << "What would you like to do?" << endl;
		cout << "Type 'ADD' to create a random new entry for a student." << endl;
		cout << "Type 'PRINT' to print out all the students currently stored." << endl;
		cout << "Type 'DELETE' to delete a student." << endl;
		cout << "Type 'QUIT' to exit." << endl;
		cin >> input;
		validinput = false;

		//ensure that there is the correct input otherwise re ask
		while (input != "ADD" && input != "PRINT" && input != "QUIT" && input != "DELETE" ) {
			cout << "Invalid input of " << input << ", please try again." << endl;
			cin >> input;
		}

//determine what to do depending on the input
		if (input == "ADD") {
			keepadding = true;
			//if the user wants to keep adding, ask again and do again while makig sure the input is valid
			while (keepadding == true) {
				cout << "Would you like to add randomly or manually?(Type 'random' or 'manual')" << endl;
				cin >> type;
				if (type == "random") {
					//determine how many students to generate and add
					cout << "How many students would you like to generate?" << endl;
					cin >> amount;
					int count = 0;
					while (count <= amount) {
						addStudent(generator->GetRandomStudent(ids));
						count++;
					}
					
				}
				else if (type == "manual") {
					Student* student = new Student();
					bool invalidid = getInfo(student);
					// if they enter a new ID, student gets added. If not, program alerts user and the student is deleted
					if (invalidid == false) {
						addStudent(student);
					}
					else {
						cout << "Oops this ID is taken already ID\n";
						delete student;
					}
				}
				cout << "Would you like to add another student? Yes or no." << endl;
				cin >> answer;
		  		
					if (answer == "yes" || answer == "Yes" || answer == "YES" || answer == "y" || answer == "Y"){
						keepadding = true;
					}
					else if (answer == "no" || answer == "No" || answer == "NO" || answer == "n" || answer == "N") {
						keepadding = false;
					}
			
			}
		}
		else if (input == "PRINT") {
			printStudent();
		}
		else if (input == "DELETE") {
			int id;
			// asks for ID then deletes
			cout << "Which ID would you like to delete?\n";
			cin >> id;
			deleteStudent(id);
		}
		else if (input == "QUIT") {
			cout << "Thanks!" << endl;
			running = false;
		}
		else {
			cout << "Invalid input" << endl;
		}
		
	}
  return 0;
}

//asks for user info
bool getInfo(Student* &newstudent) {
  newstudent->first = new char[80];
  newstudent->last = new char[80];
  cout << "Enter first name" << endl;
  cin >> newstudent->first;
  cout << "Enter last name" << endl;
  cin >> newstudent->last;
  cout << "Enter id number" << endl;
  cin >> newstudent->id;
  cout << "Enter GPA" << endl;
  cin >> newstudent->gpa;

//checks whether the id already exists
  	for (vector<int>::iterator it = ids.begin(); it != ids.end(); ++it) {
		if (*it == newstudent->id) {
			return true;
		}
	}
	// if it dosent it will be added to vector 
	ids.push_back(newstudent->id);
	return false;

}



//function to add student 
void addStudent(Student* newstudent) {
 	int nodes = 0;
	// gets a key that is generated by our hashTablefunction based on first name
	int key = generator->hashFunc(newstudent->first, hashSize);
	// current is then assigned to the correct node of specific key
	Student* current = hashTable[key];
	// if that spot was empty, the student takes that spot
	if (current == NULL) {
		hashTable[key] = newstudent;
	}
	// otherwis loops through key's linked list and add to end
	else {
		while (current->next != NULL) {
			nodes++;
			current = current->next;
		}
		current->next = newstudent;
		newstudent->next = NULL;
		// when the nodes is 1 there are three students in the linkedlist the table is then rehashed
		if (nodes == 1) {
			rehash();
		}
	}
}

//function to print student 
void printStudent() {
	// loops through hastable
	for (int i = 0; i < hashSize; i++) {
		Student* ptr = hashTable[i];
		// loops through linked list 
		while (ptr != NULL) {
			// prints  student and moves next student in list
			cout << "Key: " << i << " Name: " << ptr->first << " " << ptr->last  << ", ID: " << ptr->id << ", GPA: " << fixed << setprecision(2) << ptr->gpa << endl;
			ptr = ptr->next;
		}

	}
}

//function to delete student 
//loops through hashTabletable and corresponding linked lists to find correct id to delete
void deleteStudent(int id) {
	Student* current = NULL;
	Student* previous = NULL;
	// loops through hashTabletable
	for (int i = 0; i < hashSize; i++) {
		if (hashTable[i] != NULL) {
			current = hashTable[i];
			// loops through linked list
			while (current != NULL) {
				if (current->id == id) {
					if (previous != NULL) {
						// ID is found, the node is then skipped and deleted
						previous->next = current->next;
						delete current;
						current = NULL;
					}
					else {
						// if the node to be deleted is the first in list the second node is then head and first node is deleted. 
						hashTable[i] = current->next;
						delete current;
						current = NULL;
					}
				}
				else {
					// goes to next node in linked list
					previous = current;
					current = current->next;
				}
			}
		}
		// resets the current and previous nodes
		current = NULL;
		previous = NULL;
	}
}


void rehash(){
	// creates a temporary array to set equal to hashtable
	Student** temp = new Student* [hashSize];
	for (int i = 0; i < hashSize; i++) {
		temp[i] = hashTable[i];
	}
	// hashSize doubles 
	 hashSize = hashSize * 2;
	 // new hashtableis made and set  to NULL
	 hashTable = new Student* [hashSize];
	 for (int i = 0; i < hashSize; i++) {
		 hashTable[i] = NULL;
	 }
	 // adds old hashTable information to new hashTable
	 for (int i = 0; i < (hashSize/2); i++) {
		 if (temp[i] != NULL) {
			 addStudent(temp[i]);
		 }
	 }
	 // delete old table
	 delete[] temp;
}











